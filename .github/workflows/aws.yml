# name: ğŸš€ Deploy App to EC2 Production

# on:
#   push:
#     branches: [ "main" ]
#   workflow_dispatch:
#     inputs:
#       force_deploy:
#         description: 'Force deployment even if tests fail'
#         required: false
#         default: 'false'

# env:
#   DOCKER_USERNAME: jefee
#   DOCKER_FRONTEND_REPO: jefee/yanotela-frontend
#   DOCKER_BACKEND_REPO: jefee/yanotela-backend
#   EC2_HOST: 13.36.209.205
#   EC2_USER: ubuntu
#   DEPLOY_PATH: /var/www/yanotela
#   DOCKER_BUILDKIT: 1
#   COMPOSE_DOCKER_CLI_BUILD: 1

# permissions:
#   contents: read

# jobs:
#   # ===== TESTS =====
#   test-backend:
#     name: ğŸ§ª Test Backend
#     runs-on: ubuntu-latest

#     services:
#       postgres:
#         image: postgres:15-alpine
#         env:
#           POSTGRES_USER: test_user
#           POSTGRES_PASSWORD: test_pass
#           POSTGRES_DB: test_db
#         options: >-
#           --health-cmd pg_isready
#           --health-interval 10s
#           --health-timeout 5s
#           --health-retries 5
#         ports:
#           - 5432:5432

#     steps:
#     - name: ğŸ“¥ Checkout Code
#       uses: actions/checkout@v4

#     - name: ğŸ”§ Setup Node.js
#       uses: actions/setup-node@v4
#       with:
#         node-version: '20'
#         cache: 'npm'
#         cache-dependency-path: Server/package-lock.json

#     - name: ğŸ“¦ Install Backend Dependencies
#       run: |
#         cd Server
#         npm ci

#     - name: ğŸ—„ï¸ Setup Test Database
#       run: |
#         cd Server
#         cp .env.example .env.test || echo "DATABASE_URL=postgresql://test_user:test_pass@localhost:5432/test_db" > .env.test
#         echo "NODE_ENV=test" >> .env.test
#         npx prisma generate
#         npx prisma migrate deploy
#       env:
#         DATABASE_URL: postgresql://test_user:test_pass@localhost:5432/test_db

#     - name: ğŸ§ª Run Backend Tests
#       run: |
#         cd Server
#         npm run test:ci || npm test
#       env:
#         NODE_ENV: test
#         DATABASE_URL: postgresql://test_user:test_pass@localhost:5432/test_db

#   test-frontend:
#     name: ğŸ§ª Test Frontend
#     runs-on: ubuntu-latest

#     steps:
#     - name: ğŸ“¥ Checkout Code
#       uses: actions/checkout@v4

#     - name: ğŸ”§ Setup Node.js
#       uses: actions/setup-node@v4
#       with:
#         node-version: '20'
#         cache: 'npm'
#         cache-dependency-path: Client/package-lock.json

#     - name: ğŸ“¦ Install Frontend Dependencies
#       run: |
#         cd Client
#         npm ci

#     - name: ğŸ” TypeScript Check
#       run: |
#         cd Client
#         npm run type-check || npx tsc --noEmit

#     - name: ğŸ—ï¸ Build Frontend
#       run: |
#         cd Client
#         npm run build

#     - name: ğŸ§ª Run Frontend Tests (if available)
#       run: |
#         cd Client
#         npm run test || echo "No frontend tests configured"
#       continue-on-error: true

#   # ===== BUILD AND DEPLOY =====
#   build-and-deploy:
#     name: ğŸ³ Build and Deploy
#     runs-on: ubuntu-latest
#     needs: [test-backend, test-frontend]
#     if: success() || github.event.inputs.force_deploy == 'true'
#     environment: production

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v3

#       - name: Login to Docker Hub
#         uses: docker/login-action@v3
#         with:
#           username: ${{ env.DOCKER_USERNAME }}
#           password: ${{ secrets.DOCKER_PASSWORD }}

#       - name: Build and push frontend image
#         uses: docker/build-push-action@v5
#         with:
#           context: ./Client
#           platforms: linux/amd64
#           push: true
#           tags: |
#             ${{ env.DOCKER_FRONTEND_REPO }}:latest
#             ${{ env.DOCKER_FRONTEND_REPO }}:${{ github.sha }}
#           cache-from: type=gha
#           cache-to: type=gha,mode=max

#       - name: Build and push backend image
#         uses: docker/build-push-action@v5
#         with:
#           context: ./Server
#           platforms: linux/amd64
#           push: true
#           tags: |
#             ${{ env.DOCKER_BACKEND_REPO }}:latest
#             ${{ env.DOCKER_BACKEND_REPO }}:${{ github.sha }}
#           cache-from: type=gha
#           cache-to: type=gha,mode=max
#         continue-on-error: false

#       - name: ğŸ” Setup SSH
#         uses: webfactory/ssh-agent@v0.8.0
#         with:
#           ssh-private-key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}

#       - name: ğŸš€ Deploy to EC2
#         run: |
#           ssh -o StrictHostKeyChecking=no ${{ env.EC2_USER }}@${{ env.EC2_HOST }} << 'EOF'
#             echo "âœ… SSH connection successful!"
#             whoami
#             pwd
            
#             cd ${{ env.DEPLOY_PATH }}
            
#             # Create backup of current deployment
#             echo "ğŸ“¦ Creating backup..."
#             if [ -d "backup" ]; then rm -rf backup; fi
#             if [ -f "docker-compose.prod.yml" ]; then
#               mkdir -p backup
#               sudo docker compose -f docker-compose.prod.yml ps > backup/services_status.txt 2>/dev/null || true
#               cp .env.prod backup/ 2>/dev/null || true
#             fi
            
#             # Update package cache (Ubuntu-specific)
#             sudo apt-get update -qq
            
#             # Pull latest images
#             echo "ğŸ“¥ Pulling latest images..."
#             sudo docker compose -f docker-compose.prod.yml pull
            
#             # Stop current services
#             echo "ğŸ›‘ Stopping current services..."
#             sudo docker compose -f docker-compose.prod.yml down
            
#             # Load environment variables and start new services
#             echo "ğŸš€ Starting new services..."
#             set -a
#             source .env.prod
#             set +a
            
#             sudo -E DOCKER_USERNAME=${{ env.DOCKER_USERNAME }} IMAGE_TAG=latest docker compose -f docker-compose.prod.yml up -d
            
#             # Wait for services to be ready
#             echo "â³ Waiting for services to be ready..."
#             sleep 30
            
#             # Health check
#             if ! sudo docker compose -f docker-compose.prod.yml ps | grep -q "Up"; then
#               echo "âŒ Deployment failed - services not running"
#               echo "ğŸ”„ Rolling back..."
#               sudo docker compose -f docker-compose.prod.yml down
#               if [ -f "backup/services_status.txt" ]; then
#                 cp backup/.env.prod .env.prod 2>/dev/null || true
#                 sudo docker compose -f docker-compose.prod.yml up -d
#               fi
#               exit 1
#             fi
            
#             # Test services
#             echo "ğŸ¥ Testing services..."
            
#             # Test frontend
#             if curl -f -s -m 10 http://localhost:3000 > /dev/null; then
#               echo "âœ… Frontend is responding"
#             else
#               echo "âŒ Frontend is not responding"
#               sudo docker compose -f docker-compose.prod.yml logs yanotela-frontend-prod
#               exit 1
#             fi
            
#             # Test backend
#             if curl -f -s -m 10 http://localhost:3001/health > /dev/null; then
#               echo "âœ… Backend is responding"
#             else
#               echo "âŒ Backend is not responding"
#               sudo docker compose -f docker-compose.prod.yml logs yanotela-backend-prod
#               exit 1
#             fi
            
#             # Clean up old images
#             sudo docker image prune -f
            
#             echo "ğŸ‰ Deployment completed successfully!"
#           EOF

#   # ===== NOTIFICATIONS =====
#   notify:
#     name: ğŸ“§ Send Notifications
#     runs-on: ubuntu-latest
#     needs: [build-and-deploy]
#     if: always()

#     steps:
#     - name: ğŸ“§ Send Success Email
#       if: needs.build-and-deploy.result == 'success'
#       uses: dawidd6/action-send-mail@v3
#       with:
#         server_address: smtp.gmail.com
#         server_port: 587
#         username: ${{ secrets.NOTIFICATION_EMAIL }}
#         password: ${{ secrets.NOTIFICATION_EMAIL_PASSWORD }}
#         subject: "âœ… Yanotela Production Deployment Successful"
#         to: ${{ secrets.NOTIFICATION_EMAIL }}
#         from: GitHub Actions <noreply@github.com>
#         body: |
#           ğŸ‰ Production deployment completed successfully!

#           ğŸ“‹ Deployment Details:
#           â€¢ Repository: ${{ github.repository }}
#           â€¢ Branch: ${{ github.ref_name }}
#           â€¢ Commit: ${{ github.sha }}
#           â€¢ Actor: ${{ github.actor }}
#           â€¢ Workflow: ${{ github.workflow }}

#           ğŸ”— Links:
#           â€¢ Frontend: http://${{ env.EC2_HOST }}:3000
#           â€¢ Backend API: http://${{ env.EC2_HOST }}:3001
#           â€¢ GitHub Action: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

#           â° Deployment completed at: $(date)

#     - name: ğŸ“§ Send Failure Email
#       if: needs.build-and-deploy.result == 'failure'
#       uses: dawidd6/action-send-mail@v3
#       with:
#         server_address: smtp.gmail.com
#         server_port: 587
#         username: ${{ secrets.NOTIFICATION_EMAIL }}
#         password: ${{ secrets.NOTIFICATION_EMAIL_PASSWORD }}
#         subject: "ğŸš¨ Yanotela Production Deployment FAILED"
#         to: ${{ secrets.NOTIFICATION_EMAIL }}
#         from: GitHub Actions <noreply@github.com>
#         body: |
#           ğŸš¨ Production deployment has FAILED!

#           ğŸ“‹ Deployment Details:
#           â€¢ Repository: ${{ github.repository }}
#           â€¢ Branch: ${{ github.ref_name }}
#           â€¢ Commit: ${{ github.sha }}
#           â€¢ Actor: ${{ github.actor }}
#           â€¢ Workflow: ${{ github.workflow }}

#           ğŸ” Check the logs:
#           ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

#           âš ï¸ Action Required: Please check the deployment logs and fix any issues.

#           â° Failure detected at: $(date)
