name: Deploy App to EC2 (production)
on:
  push:
    branches: ["main"]
env:
  DOCKER_USERNAME: jefee
  DOCKER_FRONTEND_REPO: jefee/yanotela-frontend
  DOCKER_BACKEND_REPO: jefee/yanotela-backend
  EC2_USER: ubuntu
  DEPLOY_PATH: /var/www/yanotela
permissions:
  contents: read

jobs:
  # Job 1: Build Frontend en parall√®le
  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./Client
          platforms: linux/amd64
          push: true
          build-args: |
            NEXT_PUBLIC_API_URL=https://yanotela.fr/api
<<<<<<< HEAD
=======
            # NEXT_PUBLIC_TURNSTILE_SITE_KEY=${{ secrets.PROD_TURNSTILE_SITE_KEY }}
>>>>>>> e407d7d7a4bd527fbdadc8a8807a7ca8df0fb6b2
          tags: |
            ${{ env.DOCKER_FRONTEND_REPO }}:production
            ${{ env.DOCKER_FRONTEND_REPO }}:production-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 2: Build Backend en parall√®le
  build-backend:
    name: Build Backend
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./Server
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.DOCKER_BACKEND_REPO }}:production
            ${{ env.DOCKER_BACKEND_REPO }}:production-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 3: D√©ploiement (attend les 2 builds)
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    needs: [build-frontend, build-backend]
    steps:
      - name: Deploy to Production EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_PROD_HOST_IP }}
          username: ${{ env.EC2_USER }}
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          script: |
            echo "üöÄ Starting deployment to PRODUCTION environment"
            cd ${{ env.DEPLOY_PATH }}

            # Enable error handling
            set -e

            # Check what's using port 80
            echo "üîç Checking what's using port 80:"
            sudo netstat -tlnp | grep :80 || echo "No process found on port 80"
            sudo lsof -i :80 || echo "No files open on port 80"

            # Stop any nginx or apache processes that might be using port 80
            echo "üõë Stopping any existing web servers..."
            sudo systemctl stop nginx 2>/dev/null || true
            sudo systemctl stop apache2 2>/dev/null || true
            sudo killall nginx 2>/dev/null || true
            sudo killall apache2 2>/dev/null || true

            # Check available disk space
            echo "üìä Initial disk space:"
            df -h

            # Aggressive cleanup to free up space
            echo "üßπ Cleaning up disk space..."

            # Clean Docker system (remove all unused containers, networks, images, cache)
            docker system prune -a -f --volumes || true

            # Remove all stopped containers
            docker container prune -f || true

            # Remove all unused images
            docker image prune -a -f || true

            # Remove all unused volumes
            docker volume prune -f || true

            # Remove all unused networks
            docker network prune -f || true

            # Clean package cache
            sudo apt-get clean || true
            sudo apt-get autoremove -y || true

            # Remove old logs
            sudo journalctl --vacuum-time=3d || true

            # Clear temporary files
            sudo rm -rf /tmp/* || true
            sudo rm -rf /var/tmp/* || true

            # Remove old kernels (keep current and one backup)
            sudo apt-get autoremove --purge -y || true

            echo "üìä Disk space after cleanup:"
            df -h

            # Log in to Docker Hub to pull images
            echo "üîë Logging in to Docker Hub..."
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u ${{ env.DOCKER_USERNAME }} --password-stdin

            # Clone ou mise √† jour du d√©p√¥t
            if [ ! -d ".git" ]; then
              git clone -b main https://github.com/FlorianMMI/Yanotela.git .
            else
              git fetch origin
              git reset --hard origin/main
            fi

            # Cr√©er le fichier .env
            cat > .env << 'EOF'
            ${{ secrets.ENV_PROD_FILE }}
<<<<<<< HEAD
=======
            # TURNSTILE_SITE_KEY=${{ secrets.PROD_TURNSTILE_SITE_KEY }}
            # TURNSTILE_SECRET_KEY=${{ secrets.PROD_TURNSTILE_SECRET_KEY }}
            # NEXT_PUBLIC_TURNSTILE_SITE_KEY=${{ secrets.PROD_TURNSTILE_SITE_KEY }}
            NODE_ENV=development
>>>>>>> e407d7d7a4bd527fbdadc8a8807a7ca8df0fb6b2
            EOF

            # Arr√™ter les anciens conteneurs
            echo "üõë Stopping existing containers..."
            docker compose down || true

            # More aggressive cleanup
            echo "üßπ Aggressive cleanup of Docker resources..."
            docker system prune -a -f --volumes || true

            # Remove any dangling images specifically
            docker rmi $(docker images -f "dangling=true" -q) 2>/dev/null || true

            # Check disk space before proceeding
            echo "üìä Disk space before pulling images:"
            df -h

            # Ensure we have enough space (at least 2GB free)
            AVAILABLE_SPACE=$(df / | tail -1 | awk '{print $4}')
            if [ "$AVAILABLE_SPACE" -lt 2000000 ]; then
              echo "‚ùå Insufficient disk space: ${AVAILABLE_SPACE}KB available"
              echo "üÜò Emergency cleanup..."
              
              # Emergency cleanup - remove everything
              docker system prune -a -f --volumes
              docker container prune -f
              docker image prune -a -f
              docker volume prune -f
              
              # Check if we freed enough space
              AVAILABLE_SPACE=$(df / | tail -1 | awk '{print $4}')
              if [ "$AVAILABLE_SPACE" -lt 1000000 ]; then
                echo "‚ùå Still insufficient disk space after cleanup: ${AVAILABLE_SPACE}KB"
                echo "üìã Please manually clean up the EC2 instance"
                exit 1
              fi
            fi

            # Tirer les nouvelles images une par une pour √©conomiser l'espace
            echo "üì• Pulling images one by one..."
            docker pull ${{ env.DOCKER_BACKEND_REPO }}:production
            docker pull ${{ env.DOCKER_FRONTEND_REPO }}:production
            docker pull postgres:15-alpine
            docker pull redis:7-alpine
            docker pull nginx:latest

            # D√©marrer les services
            echo "üöÄ Starting services..."
            docker compose up -d --force-recreate

            # Attendre que les services d√©marrent
            echo "‚è≥ Waiting for services to start..."
            sleep 60

            # V√©rifier que les services sont d√©marr√©s
            echo "üîç Checking service status..."
            docker compose ps

            if docker compose ps | grep -E "(Up|running)"; then
              echo "‚úÖ Services d√©marr√©s avec succ√®s"
              
            # Test de connectivit√©
            echo "üß™ Testing connectivity..."
            if curl -f -s -m 10 http://localhost > /dev/null; then
              echo "‚úÖ Nginx is responding"
            else
              echo "‚ö†Ô∏è Nginx not responding yet"
            fi

            if curl -f -s -m 10 http://localhost:3001/health > /dev/null; then
              echo "‚úÖ Backend is responding"
            else
              echo "‚ö†Ô∏è Backend not responding yet"
            fi

            # Final deployment status report
            echo ""
            echo "üéâ DEPLOYMENT COMPLETE! üéâ"
            echo "========================================="
            if [ "$NGINX_PORT" = "80" ]; then
              echo "‚úÖ Application: https://yanotela.fr"
              echo "üîó API Endpoint: https://yanotela.fr/api"
            else
              echo "‚úÖ Application: https://yanotela.fr:8080"
              echo "üîó API Endpoint: https://yanotela.fr:8080/api"
              echo "‚ö†Ô∏è  Note: Using port 8080 due to port conflict"
            fi
            echo "üñ•Ô∏è  Direct Frontend: https://yanotela.fr:3000"
            echo "üîß Direct Backend: https://yanotela.fr:3001"
            echo "========================================="              # Final cleanup to free up space
              echo "üßπ Final cleanup..."
              docker system prune -f || true
              
              echo "üìä Final disk space:"
              df -h
            else
              echo "‚ùå √âchec du d√©marrage des services"
              echo "üìã Container logs:"
              docker compose logs --tail=50
              echo "üìä System resources:"
              df -h
              free -h
              exit 1
            fi